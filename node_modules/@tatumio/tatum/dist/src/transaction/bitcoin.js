"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.sendBitcoinTransaction = exports.prepareBitcoinSignedTransaction = exports.signBitcoinKMSTransaction = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const bitcoinjs_lib_1 = require("bitcoinjs-lib");
const blockchain_1 = require("../blockchain");
const tatum_1 = require("../connector/tatum");
const model_1 = require("../model");
const prepareSignedTransaction = async (network, body, currency) => {
    await tatum_1.validateBody(body, model_1.TransferBtcBasedBlockchain);
    const { fromUTXO, fromAddress, to } = body;
    const tx = new bitcoinjs_lib_1.TransactionBuilder(network);
    const privateKeysToSign = [];
    if (fromAddress) {
        for (const item of fromAddress) {
            const txs = await blockchain_1.btcGetTxForAccount(item.address);
            for (const t of txs) {
                for (const [i, o] of t.outputs.entries()) {
                    if (o.address !== item.address) {
                        continue;
                    }
                    try {
                        await blockchain_1.btcGetUTXO(t.hash, i);
                        tx.addInput(t.hash, i);
                        privateKeysToSign.push(item.privateKey);
                    }
                    catch (e) {
                    }
                }
            }
        }
    }
    else if (fromUTXO) {
        for (const item of fromUTXO) {
            tx.addInput(item.txHash, item.index);
            privateKeysToSign.push(item.privateKey);
        }
    }
    for (const item of to) {
        tx.addOutput(item.address, Number(new bignumber_js_1.default(item.value).multipliedBy(100000000).toFixed(8, bignumber_js_1.default.ROUND_FLOOR)));
    }
    for (let i = 0; i < privateKeysToSign.length; i++) {
        const ecPair = bitcoinjs_lib_1.ECPair.fromWIF(privateKeysToSign[i], network);
        tx.sign(i, ecPair);
    }
    return tx.build().toHex();
};
/**
 * Sign Bitcoin pending transaction from Tatum KMS
 * @param tx pending transaction from KMS
 * @param privateKeys private keys to sign transaction with.
 * @param testnet mainnet or testnet version
 * @returns transaction data to be broadcast to blockchain.
 */
exports.signBitcoinKMSTransaction = async (tx, privateKeys, testnet) => {
    if (tx.chain !== model_1.Currency.BTC) {
        throw Error('Unsupported chain.');
    }
    const network = testnet ? bitcoinjs_lib_1.networks.testnet : bitcoinjs_lib_1.networks.bitcoin;
    const builder = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(bitcoinjs_lib_1.Transaction.fromHex(tx.serializedTransaction), network);
    for (const [i, privateKey] of privateKeys.entries()) {
        const ecPair = bitcoinjs_lib_1.ECPair.fromWIF(privateKey, network);
        builder.sign(i, ecPair);
    }
    return builder.build().toHex();
};
/**
 * Sign Bitcoin transaction with private keys locally. Nothing is broadcast to the blockchain.
 * @param testnet mainnet or testnet version
 * @param body content of the transaction to broadcast
 * @returns transaction data to be broadcast to blockchain.
 */
exports.prepareBitcoinSignedTransaction = async (testnet, body) => {
    return prepareSignedTransaction(testnet ? bitcoinjs_lib_1.networks.testnet : bitcoinjs_lib_1.networks.bitcoin, body, model_1.Currency.BTC);
};
/**
 * Send Bitcoin transaction to the blockchain. This method broadcasts signed transaction to the blockchain.
 * This operation is irreversible.
 * @param testnet mainnet or testnet version
 * @param body content of the transaction to broadcast
 * @returns transaction id of the transaction in the blockchain
 */
exports.sendBitcoinTransaction = async (testnet, body) => {
    return blockchain_1.btcBroadcast(await exports.prepareBitcoinSignedTransaction(testnet, body));
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYml0Y29pbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy90cmFuc2FjdGlvbi9iaXRjb2luLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLGdFQUFxQztBQUNyQyxpREFBeUY7QUFDekYsOENBSXVCO0FBQ3ZCLDhDQUFpRDtBQUNqRCxvQ0FBOEU7QUFFOUUsTUFBTSx3QkFBd0IsR0FBRyxLQUFLLEVBQUUsT0FBZ0IsRUFBRSxJQUFnQyxFQUFFLFFBQWtCLEVBQUUsRUFBRTtJQUM5RyxNQUFNLG9CQUFZLENBQUMsSUFBSSxFQUFFLGtDQUEwQixDQUFDLENBQUM7SUFDckQsTUFBTSxFQUFDLFFBQVEsRUFBRSxXQUFXLEVBQUUsRUFBRSxFQUFDLEdBQUcsSUFBSSxDQUFDO0lBQ3pDLE1BQU0sRUFBRSxHQUFHLElBQUksa0NBQWtCLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDM0MsTUFBTSxpQkFBaUIsR0FBYSxFQUFFLENBQUM7SUFDdkMsSUFBSSxXQUFXLEVBQUU7UUFDYixLQUFLLE1BQU0sSUFBSSxJQUFJLFdBQVcsRUFBRTtZQUM5QixNQUFNLEdBQUcsR0FBRyxNQUFNLCtCQUFrQixDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUNqRCxLQUFLLE1BQU0sQ0FBQyxJQUFJLEdBQUcsRUFBRTtnQkFDakIsS0FBSyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFLEVBQUU7b0JBQ3RDLElBQUksQ0FBQyxDQUFDLE9BQU8sS0FBSyxJQUFJLENBQUMsT0FBTyxFQUFFO3dCQUM1QixTQUFTO3FCQUNaO29CQUNELElBQUk7d0JBQ0EsTUFBTSx1QkFBVSxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUM7d0JBQzVCLEVBQUUsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQzt3QkFDdkIsaUJBQWlCLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztxQkFDM0M7b0JBQUMsT0FBTyxDQUFDLEVBQUU7cUJBQ1g7aUJBQ0o7YUFDSjtTQUNKO0tBQ0o7U0FBTSxJQUFJLFFBQVEsRUFBRTtRQUNqQixLQUFLLE1BQU0sSUFBSSxJQUFJLFFBQVEsRUFBRTtZQUN6QixFQUFFLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ3JDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7U0FDM0M7S0FDSjtJQUNELEtBQUssTUFBTSxJQUFJLElBQUksRUFBRSxFQUFFO1FBQ25CLEVBQUUsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxNQUFNLENBQUMsSUFBSSxzQkFBUyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxZQUFZLENBQUMsU0FBUyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsRUFBRSxzQkFBUyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUMzSDtJQUVELEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxpQkFBaUIsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7UUFDL0MsTUFBTSxNQUFNLEdBQUcsc0JBQU0sQ0FBQyxPQUFPLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxDQUFDLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFDN0QsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUM7S0FDdEI7SUFDRCxPQUFPLEVBQUUsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxLQUFLLEVBQUUsQ0FBQztBQUM5QixDQUFDLENBQUM7QUFFRjs7Ozs7O0dBTUc7QUFDVSxRQUFBLHlCQUF5QixHQUFHLEtBQUssRUFBRSxFQUFrQixFQUFFLFdBQXFCLEVBQUUsT0FBZ0IsRUFBRSxFQUFFO0lBQzNHLElBQUksRUFBRSxDQUFDLEtBQUssS0FBSyxnQkFBUSxDQUFDLEdBQUcsRUFBRTtRQUMzQixNQUFNLEtBQUssQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO0tBQ3JDO0lBQ0QsTUFBTSxPQUFPLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQyx3QkFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsd0JBQVEsQ0FBQyxPQUFPLENBQUM7SUFDOUQsTUFBTSxPQUFPLEdBQUcsa0NBQWtCLENBQUMsZUFBZSxDQUFDLDJCQUFXLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxxQkFBcUIsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQzNHLEtBQUssTUFBTSxDQUFDLENBQUMsRUFBRSxVQUFVLENBQUMsSUFBSSxXQUFXLENBQUMsT0FBTyxFQUFFLEVBQUU7UUFDakQsTUFBTSxNQUFNLEdBQUcsc0JBQU0sQ0FBQyxPQUFPLENBQUMsVUFBVSxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBQ25ELE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0tBQzNCO0lBQ0QsT0FBTyxPQUFPLENBQUMsS0FBSyxFQUFFLENBQUMsS0FBSyxFQUFFLENBQUM7QUFDbkMsQ0FBQyxDQUFDO0FBRUY7Ozs7O0dBS0c7QUFDVSxRQUFBLCtCQUErQixHQUFHLEtBQUssRUFBRSxPQUFnQixFQUFFLElBQWdDLEVBQUUsRUFBRTtJQUN4RyxPQUFPLHdCQUF3QixDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsd0JBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLHdCQUFRLENBQUMsT0FBTyxFQUFFLElBQUksRUFBRSxnQkFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ3ZHLENBQUMsQ0FBQztBQUVGOzs7Ozs7R0FNRztBQUNVLFFBQUEsc0JBQXNCLEdBQUcsS0FBSyxFQUFFLE9BQWdCLEVBQUUsSUFBZ0MsRUFBRSxFQUFFO0lBQy9GLE9BQU8seUJBQVksQ0FBQyxNQUFNLHVDQUErQixDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDO0FBQzlFLENBQUMsQ0FBQyJ9