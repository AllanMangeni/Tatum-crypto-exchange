"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.sendLitecoinTransaction = exports.prepareLitecoinSignedTransaction = exports.signLitecoinKMSTransaction = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const bitcoinjs_lib_1 = require("bitcoinjs-lib");
const blockchain_1 = require("../blockchain");
const tatum_1 = require("../connector/tatum");
const constants_1 = require("../constants");
const model_1 = require("../model");
const prepareSignedTransaction = async (network, body) => {
    await tatum_1.validateBody(body, model_1.TransferBtcBasedBlockchain);
    const { fromUTXO, fromAddress, to } = body;
    const tx = new bitcoinjs_lib_1.TransactionBuilder(network);
    const privateKeysToSign = [];
    if (fromAddress) {
        for (const item of fromAddress) {
            const txs = await blockchain_1.ltcGetTxForAccount(item.address);
            for (const t of txs) {
                for (const [i, o] of t.outputs.entries()) {
                    if (o.address !== item.address) {
                        continue;
                    }
                    try {
                        await blockchain_1.ltcGetUTXO(t.hash, i);
                        tx.addInput(t.hash, i);
                        privateKeysToSign.push(item.privateKey);
                    }
                    catch (e) {
                    }
                }
            }
        }
    }
    else if (fromUTXO) {
        for (const item of fromUTXO) {
            tx.addInput(item.txHash, item.index);
            privateKeysToSign.push(item.privateKey);
        }
    }
    for (const item of to) {
        tx.addOutput(item.address, Number(new bignumber_js_1.default(item.value).multipliedBy(100000000).toFixed(8, bignumber_js_1.default.ROUND_FLOOR)));
    }
    for (let i = 0; i < privateKeysToSign.length; i++) {
        const ecPair = bitcoinjs_lib_1.ECPair.fromWIF(privateKeysToSign[i], network);
        tx.sign(i, ecPair);
    }
    return tx.build().toHex();
};
/**
 * Sign Litecoin pending transaction from Tatum KMS
 * @param tx pending transaction from KMS
 * @param privateKeys private keys to sign transaction with.
 * @param testnet mainnet or testnet version
 * @returns transaction data to be broadcast to blockchain.
 */
exports.signLitecoinKMSTransaction = async (tx, privateKeys, testnet) => {
    if (tx.chain !== model_1.Currency.LTC) {
        throw Error('Unsupported chain.');
    }
    const network = testnet ? constants_1.LTC_TEST_NETWORK : constants_1.LTC_NETWORK;
    const builder = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(bitcoinjs_lib_1.Transaction.fromHex(tx.serializedTransaction), network);
    for (const [i, privateKey] of privateKeys.entries()) {
        const ecPair = bitcoinjs_lib_1.ECPair.fromWIF(privateKey, network);
        builder.sign(i, ecPair);
    }
    return builder.build().toHex();
};
/**
 * Sign Litcoin transaction with private keys locally. Nothing is broadcast to the blockchain.
 * @param testnet mainnet or testnet version
 * @param body content of the transaction to broadcast
 * @returns transaction data to be broadcast to blockchain.
 */
exports.prepareLitecoinSignedTransaction = async (testnet, body) => {
    return prepareSignedTransaction(testnet ? constants_1.LTC_TEST_NETWORK : constants_1.LTC_NETWORK, body);
};
/**
 * Send Litecoin transaction to the blockchain. This method broadcasts signed transaction to the blockchain.
 * This operation is irreversible.
 * @param testnet mainnet or testnet version
 * @param body content of the transaction to broadcast
 * @returns transaction id of the transaction in the blockchain
 */
exports.sendLitecoinTransaction = async (testnet, body) => {
    return blockchain_1.ltcBroadcast(await exports.prepareLitecoinSignedTransaction(testnet, body));
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGl0ZWNvaW4uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvdHJhbnNhY3Rpb24vbGl0ZWNvaW4udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsZ0VBQXFDO0FBQ3JDLGlEQUErRTtBQUMvRSw4Q0FBMkU7QUFDM0UsOENBQWdEO0FBQ2hELDRDQUEyRDtBQUMzRCxvQ0FBOEU7QUFFOUUsTUFBTSx3QkFBd0IsR0FBRyxLQUFLLEVBQUUsT0FBZ0IsRUFBRSxJQUFnQyxFQUFFLEVBQUU7SUFDMUYsTUFBTSxvQkFBWSxDQUFDLElBQUksRUFBRSxrQ0FBMEIsQ0FBQyxDQUFDO0lBQ3JELE1BQU0sRUFBQyxRQUFRLEVBQUUsV0FBVyxFQUFFLEVBQUUsRUFBQyxHQUFHLElBQUksQ0FBQztJQUN6QyxNQUFNLEVBQUUsR0FBRyxJQUFJLGtDQUFrQixDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQzNDLE1BQU0saUJBQWlCLEdBQWEsRUFBRSxDQUFDO0lBQ3ZDLElBQUksV0FBVyxFQUFFO1FBQ2IsS0FBSyxNQUFNLElBQUksSUFBSSxXQUFXLEVBQUU7WUFDNUIsTUFBTSxHQUFHLEdBQUcsTUFBTSwrQkFBa0IsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDbkQsS0FBSyxNQUFNLENBQUMsSUFBSSxHQUFHLEVBQUU7Z0JBQ2pCLEtBQUssTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxFQUFFO29CQUN0QyxJQUFJLENBQUMsQ0FBQyxPQUFPLEtBQUssSUFBSSxDQUFDLE9BQU8sRUFBRTt3QkFDNUIsU0FBUztxQkFDWjtvQkFDRCxJQUFJO3dCQUNBLE1BQU0sdUJBQVUsQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDO3dCQUM1QixFQUFFLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUM7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