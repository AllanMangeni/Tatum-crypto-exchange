"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const { bech32, derivePrivate, derivePublic, getPubKeyBlake2b224Hash, mnemonicToRootKeypair, packBaseAddress, } = require('cardano-crypto.js');
const constants_1 = require("../constants");
/**
 * Generate an Ada key for the standard derivation path
 * @param mnemonic mnemonic seed to use
 * @returns the key buffer
 */
const generateKey = async (mnemonic) => {
    const walletSecret = await mnemonicToRootKeypair(mnemonic, constants_1.ADA_DERIVATION_SCHEME);
    return constants_1.ADA_DERIVATION_PATH
        .split('/')
        .slice(1)
        .map(index => index.slice(-1) === '\'' ? constants_1.HARDENED_THRESHOLD + parseInt(index.slice(0, -1)) : parseInt(index))
        .reduce((secret, index) => derivePrivate(secret, index, constants_1.ADA_DERIVATION_SCHEME), walletSecret);
};
/**
 * Generate an Ada private key for the standard derivation path
 * @param mnemonic mnemonic seed to use
 * @param i derivation index of private key to generate
 * @returns the (extended) private key string
 */
const generatePrivateKey = async (mnemonic, i) => {
    // /0/i
    return derivePrivate(derivePrivate(await generateKey(mnemonic), 0, constants_1.ADA_DERIVATION_SCHEME), i, constants_1.ADA_DERIVATION_SCHEME).toString('hex');
};
/**
 * Generate an Ada public key for the standard derivation path
 * @param mnemonic mnemonic seed to use
 * @returns the extended public key string (spend + stake)
 */
const generateXPublicKey = async (mnemonic) => {
    const root = await generateKey(mnemonic);
    // /0
    const spendXPub = derivePrivate(root, 0, constants_1.ADA_DERIVATION_SCHEME).slice(64, 128).toString('hex');
    // /2/0
    const stakeXPub = derivePrivate(derivePrivate(root, 2, constants_1.ADA_DERIVATION_SCHEME), 0, constants_1.ADA_DERIVATION_SCHEME).slice(64, 128).toString('hex');
    return spendXPub + stakeXPub;
};
function xpub2blake2b224Hash(xpub) {
    return getPubKeyBlake2b224Hash(Buffer.from(xpub, 'hex').slice(0, 32));
}
/**
 * Generate Carnado address
 * @param testnet extended public key to generate address from
 * @param xpub extended public key to generate address from
 * @param i derivation index of address to generate. Up to 2^31 addresses can be generated.
 * @returns blockchain address
 */
const generateAddress = async (testnet, xpub, i) => {
    const spendXPub = derivePublic(Buffer.from(xpub.substr(0, 128), 'hex'), i, constants_1.ADA_DERIVATION_SCHEME);
    const stakeXPub = xpub.substr(128, 128);
    return bech32.encode(testnet ? 'addr_test' : 'addr', packBaseAddress(xpub2blake2b224Hash(spendXPub), xpub2blake2b224Hash(stakeXPub), testnet ? 0 : 1));
};
exports.default = {
    generatePrivateKey,
    generateXPublicKey,
    generateAddress
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FyZGFuby5jcnlwdG8uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvd2FsbGV0L2NhcmRhbm8uY3J5cHRvLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsTUFBTSxFQUNKLE1BQU0sRUFDTixhQUFhLEVBQ2IsWUFBWSxFQUNaLHVCQUF1QixFQUN2QixxQkFBcUIsRUFDckIsZUFBZSxHQUNoQixHQUFHLE9BQU8sQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO0FBRWpDLDRDQUlzQjtBQUV0Qjs7OztHQUlHO0FBQ0gsTUFBTSxXQUFXLEdBQUcsS0FBSyxFQUFFLFFBQWdCLEVBQW1CLEVBQUU7SUFDOUQsTUFBTSxZQUFZLEdBQUcsTUFBTSxxQkFBcUIsQ0FBQyxRQUFRLEVBQUUsaUNBQXFCLENBQUMsQ0FBQztJQUNsRixPQUFPLCtCQUFtQjtTQUN2QixLQUFLLENBQUMsR0FBRyxDQUFDO1NBQ1YsS0FBSyxDQUFDLENBQUMsQ0FBQztTQUNSLEdBQUcsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxJQUFJLENBQUMsQ0FBQyxDQUFDLDhCQUFrQixHQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUM1RyxNQUFNLENBQUMsQ0FBQyxNQUFNLEVBQUUsS0FBSyxFQUFFLEVBQUUsQ0FBQyxhQUFhLENBQUMsTUFBTSxFQUFFLEtBQUssRUFBRSxpQ0FBcUIsQ0FBQyxFQUFFLFlBQVksQ0FBQyxDQUFDO0FBQ2xHLENBQUMsQ0FBQztBQUVGOzs7OztHQUtHO0FBQ0gsTUFBTSxrQkFBa0IsR0FBRyxLQUFLLEVBQUUsUUFBZ0IsRUFBRSxDQUFTLEVBQW1CLEVBQUU7SUFDaEYsT0FBTztJQUNQLE9BQU8sYUFBYSxDQUNsQixhQUFhLENBQUMsTUFBTSxXQUFXLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxFQUFFLGlDQUFxQixDQUFDLEVBQ3BFLENBQUMsRUFDRCxpQ0FBcUIsQ0FDdEIsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDcEIsQ0FBQyxDQUFBO0FBRUQ7Ozs7R0FJRztBQUNILE1BQU0sa0JBQWtCLEdBQUcsS0FBSyxFQUFFLFFBQWdCLEVBQW1CLEVBQUU7SUFDckUsTUFBTSxJQUFJLEdBQUcsTUFBTSxXQUFXLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDekMsS0FBSztJQUNMLE1BQU0sU0FBUyxHQUFHLGFBQWEsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxFQUFFLGlDQUFxQixDQUFDLENBQUMsS0FBSyxDQUFDLEVBQUUsRUFBRSxHQUFHLENBQUMsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDL0YsT0FBTztJQUNQLE1BQU0sU0FBUyxHQUFHLGFBQWEsQ0FDN0IsYUFBYSxDQUFDLElBQUksRUFBRSxDQUFDLEVBQUUsaUNBQXFCLENBQUMsRUFBRSxDQUFDLEVBQUUsaUNBQXFCLENBQ3hFLENBQUMsS0FBSyxDQUFDLEVBQUUsRUFBRSxHQUFHLENBQUMsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDakMsT0FBTyxTQUFTLEdBQUcsU0FBUyxDQUFDO0FBQy9CLENBQUMsQ0FBQTtBQUVELFNBQVMsbUJBQW1CLENBQUMsSUFBWTtJQUN2QyxPQUFPLHVCQUF1QixDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQztBQUN4RSxDQUFDO0FBRUQ7Ozs7OztHQU1HO0FBQ0gsTUFBTSxlQUFlLEdBQUcsS0FBSyxFQUFFLE9BQWdCLEVBQUUsSUFBWSxFQUFFLENBQVMsRUFBbUIsRUFBRTtJQUMzRixNQUFNLFNBQVMsR0FBRyxZQUFZLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsRUFBRSxLQUFLLENBQUMsRUFBRSxDQUFDLEVBQUUsaUNBQXFCLENBQUMsQ0FBQztJQUNsRyxNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQztJQUN4QyxPQUFPLE1BQU0sQ0FBQyxNQUFNLENBQ2xCLE9BQU8sQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxNQUFNLEVBQzlCLGVBQWUsQ0FDYixtQkFBbUIsQ0FBQyxTQUFTLENBQUMsRUFDOUIsbUJBQW1CLENBQUMsU0FBUyxDQUFDLEVBQzlCLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQ2hCLENBQ0YsQ0FBQztBQUNKLENBQUMsQ0FBQTtBQUVELGtCQUFlO0lBQ2Isa0JBQWtCO0lBQ2xCLGtCQUFrQjtJQUNsQixlQUFlO0NBQ2hCLENBQUEifQ==