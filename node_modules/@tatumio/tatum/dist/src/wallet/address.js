"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateAddressFromPrivatekey = exports.generatePrivateKeyFromMnemonic = exports.generateAddressFromXPub = exports.toLegacyAddress = void 0;
const bip32_1 = require("bip32");
const bip39_1 = require("bip39");
const bitcoinjs_lib_1 = require("bitcoinjs-lib");
const ethereumjs_wallet_1 = __importStar(require("ethereumjs-wallet"));
// @ts-ignore
const constants_1 = require("../constants");
const model_1 = require("../model");
const tron_crypto_1 = require("./tron.crypto");
const cardano_crypto_1 = __importDefault(require("./cardano.crypto"));
// tslint:disable:no-var-requires
const bcash = require('@tatumio/bitcoincashjs2-lib');
const cashaddr = require('cashaddrjs');
const coininfo = require('coininfo');
// tslint:disable-next-line:no-var-requires
const TronWeb = require('tronweb');
/**
 * Generate Bitcoin address
 * @param testnet testnet or mainnet version of address
 * @param xpub extended public key to generate address from
 * @param i derivation index of address to generate. Up to 2^31 addresses can be generated.
 * @returns blockchain address
 */
const generateBtcAddress = (testnet, xpub, i) => {
    const network = testnet ? bitcoinjs_lib_1.networks.testnet : bitcoinjs_lib_1.networks.bitcoin;
    const w = bip32_1.fromBase58(xpub, network).derivePath(String(i));
    return bitcoinjs_lib_1.payments.p2pkh({ pubkey: w.publicKey, network }).address;
};
/**
 * Generate Dogecoin address
 * @param testnet testnet or mainnet version of address
 * @param xpub extended public key to generate address from
 * @param i derivation index of address to generate. Up to 2^31 addresses can be generated.
 * @returns blockchain address
 */
const generateDogeAddress = (testnet, xpub, i) => {
    const network = testnet ? constants_1.DOGE_TEST_NETWORK : constants_1.DOGE_NETWORK;
    const w = bip32_1.fromBase58(xpub, network).derivePath(String(i));
    return bitcoinjs_lib_1.payments.p2pkh({ pubkey: w.publicKey, network }).address;
};
/**
 * Generate Tron address
 * @param xpub extended public key to generate address from
 * @param i derivation index of address to generate. Up to 2^31 addresses can be generated.
 * @returns blockchain address
 */
const generateTronAddress = (xpub, i) => {
    const w = bip32_1.fromPublicKey(Buffer.from(xpub.slice(0, 66), 'hex'), Buffer.from(xpub.slice(-64), 'hex'));
    return TronWeb.address.fromHex(tron_crypto_1.generateAddress(w.derive(i).publicKey));
};
/**
 * Generate Litecoin address
 * @param testnet testnet or mainnet version of address
 * @param xpub extended public key to generate address from
 * @param i derivation index of address to generate. Up to 2^31 addresses can be generated.
 * @returns blockchain address
 */
const generateLtcAddress = (testnet, xpub, i) => {
    const network = testnet ? constants_1.LTC_TEST_NETWORK : constants_1.LTC_NETWORK;
    const w = bip32_1.fromBase58(xpub, network).derivePath(String(i));
    return bitcoinjs_lib_1.payments.p2pkh({ pubkey: w.publicKey, network }).address;
};
/**
 * Generate Bitcoin Cash address
 * @param testnet testnet or mainnet version of address
 * @param xpub extended public key to generate address from
 * @param i derivation index of address to generate. Up to 2^31 addresses can be generated.
 * @returns blockchain address
 */
const generateBchAddress = (testnet, xpub, i) => {
    const network = testnet ? bitcoinjs_lib_1.networks.testnet : bitcoinjs_lib_1.networks.bitcoin;
    const hdNode = bcash.HDNode.fromBase58(xpub, network);
    const legacy = hdNode.derivePath(String(i)).getAddress();
    const decoded = _decode(legacy);
    return cashaddr.encode(decoded.prefix, decoded.type, decoded.hash);
};
/**
 * Generate Ethereum or any other ERC20 address
 * @param testnet testnet or mainnet version of address
 * @param xpub extended public key to generate address from
 * @param i derivation index of address to generate. Up to 2^31 addresses can be generated.
 * @returns blockchain address
 */
const generateEthAddress = (testnet, xpub, i) => {
    const w = ethereumjs_wallet_1.hdkey.fromExtendedKey(xpub);
    const wallet = w.deriveChild(i).getWallet();
    return '0x' + wallet.getAddress().toString('hex').toLowerCase();
};
/**
 * Generate BSC or any other BEP-20 / BEP-721 address
 * @param testnet testnet or mainnet version of address
 * @param xpub extended public key to generate address from
 * @param i derivation index of address to generate. Up to 2^31 addresses can be generated.
 * @returns blockchain address
 */
const generateBscAddress = (testnet, xpub, i) => {
    return generateEthAddress(testnet, xpub, i);
};
/**
 * Generate Celo or any other ERC20 address
 * @param testnet testnet or mainnet version of address
 * @param xpub extended public key to generate address from
 * @param i derivation index of address to generate. Up to 2^31 addresses can be generated.
 * @returns blockchain address
 */
const generateCeloAddress = (testnet, xpub, i) => {
    const w = ethereumjs_wallet_1.hdkey.fromExtendedKey(xpub);
    const wallet = w.deriveChild(i).getWallet();
    return '0x' + wallet.getAddress().toString('hex').toLowerCase();
};
/**
 * Generate VeChain address
 * @param testnet testnet or mainnet version of address
 * @param xpub extended public key to generate address from
 * @param i derivation index of address to generate. Up to 2^31 addresses can be generated.
 * @returns blockchain address
 */
const generateVetAddress = (testnet, xpub, i) => {
    const w = ethereumjs_wallet_1.hdkey.fromExtendedKey(xpub);
    const wallet = w.deriveChild(i).getWallet();
    return '0x' + wallet.getAddress().toString('hex').toLowerCase();
};
/**
 * Generate Bitcoin address
 * @param testnet testnet or mainnet version of address
 * @param xpub extended public key to generate address from
 * @param i derivation index of address to generate. Up to 2^31 addresses can be generated.
 * @returns blockchain address
 */
const generateLyraAddress = (testnet, xpub, i) => {
    const network = testnet ? constants_1.LYRA_TEST_NETWORK : constants_1.LYRA_NETWORK;
    const w = bip32_1.fromBase58(xpub, network).derivePath(String(i));
    return bitcoinjs_lib_1.payments.p2pkh({ pubkey: w.publicKey, network }).address;
};
/**
 * Generate Bitcoin private key from mnemonic seed
 * @param testnet testnet or mainnet version of address
 * @param mnemonic mnemonic to generate private key from
 * @param i derivation index of private key to generate.
 * @returns blockchain private key to the address
 */
const generateBtcPrivateKey = async (testnet, mnemonic, i) => {
    const network = testnet ? bitcoinjs_lib_1.networks.testnet : bitcoinjs_lib_1.networks.bitcoin;
    return bip32_1.fromSeed(await bip39_1.mnemonicToSeed(mnemonic), network)
        .derivePath(testnet ? constants_1.TESTNET_DERIVATION_PATH : constants_1.BTC_DERIVATION_PATH)
        .derive(i)
        .toWIF();
};
/**
 * Generate Tron private key from mnemonic seed
 * @param mnemonic mnemonic to generate private key from
 * @param i derivation index of private key to generate.
 * @returns blockchain private key to the address
 */
const generateTronPrivateKey = async (mnemonic, i) => {
    var _a, _b;
    return (_b = (_a = bip32_1.fromSeed(await bip39_1.mnemonicToSeed(mnemonic))
        .derivePath(constants_1.TRON_DERIVATION_PATH)
        .derive(i)
        .privateKey) === null || _a === void 0 ? void 0 : _a.toString('hex')) !== null && _b !== void 0 ? _b : '';
};
/**
 * Generate Litecoin private key from mnemonic seed
 * @param testnet testnet or mainnet version of address
 * @param mnemonic mnemonic to generate private key from
 * @param i derivation index of private key to generate.
 * @returns blockchain private key to the address
 */
const generateLtcPrivateKey = async (testnet, mnemonic, i) => {
    const network = testnet ? constants_1.LTC_TEST_NETWORK : constants_1.LTC_NETWORK;
    return bip32_1.fromSeed(await bip39_1.mnemonicToSeed(mnemonic), network)
        .derivePath(testnet ? constants_1.TESTNET_DERIVATION_PATH : constants_1.LTC_DERIVATION_PATH)
        .derive(i)
        .toWIF();
};
/**
 * Generate Dogecoin private key from mnemonic seed
 * @param testnet testnet or mainnet version of address
 * @param mnemonic mnemonic to generate private key from
 * @param i derivation index of private key to generate.
 * @returns blockchain private key to the address
 */
const generateDogePrivateKey = async (testnet, mnemonic, i) => {
    const network = testnet ? constants_1.DOGE_TEST_NETWORK : constants_1.DOGE_NETWORK;
    return bip32_1.fromSeed(await bip39_1.mnemonicToSeed(mnemonic), network)
        .derivePath(testnet ? constants_1.TESTNET_DERIVATION_PATH : constants_1.DOGE_DERIVATION_PATH)
        .derive(i)
        .toWIF();
};
/**
 * Generate Bitcoin Cash private key from mnemonic seed
 * @param testnet testnet or mainnet version of address
 * @param mnemonic mnemonic to generate private key from
 * @param i derivation index of private key to generate.
 * @returns blockchain private key to the address
 */
const generateBchPrivateKey = async (testnet, mnemonic, i) => {
    const network = testnet ? bitcoinjs_lib_1.networks.testnet : bitcoinjs_lib_1.networks.bitcoin;
    return bip32_1.fromSeed(await bip39_1.mnemonicToSeed(mnemonic), network)
        .derivePath(constants_1.BCH_DERIVATION_PATH)
        .derive(i)
        .toWIF();
};
exports.toLegacyAddress = (address) => {
    const { prefix, type, hash } = _decode(address);
    let bitcoincash = coininfo.bitcoincash.main;
    switch (prefix) {
        case 'bitcoincash':
            bitcoincash = coininfo.bitcoincash.main;
            break;
        case 'bchtest':
            bitcoincash = coininfo.bitcoincash.test;
            break;
    }
    let version = bitcoincash.versions.public;
    switch (type) {
        case 'P2PKH':
            version = bitcoincash.versions.public;
            break;
        case 'P2SH':
            version = bitcoincash.versions.scripthash;
            break;
    }
    const hashBuf = Buffer.from(hash);
    return bcash.address.toBase58Check(hashBuf, version);
};
const _decode = (address) => {
    const { version, hash } = bcash.address.fromBase58Check(address);
    let decoded = {
        prefix: '',
        type: '',
        hash,
        format: ''
    };
    switch (version) {
        case bitcoinjs_lib_1.networks.bitcoin.pubKeyHash:
            decoded = {
                prefix: 'bitcoincash',
                type: 'P2PKH',
                hash,
                format: 'legacy'
            };
            break;
        case bitcoinjs_lib_1.networks.bitcoin.scriptHash:
            decoded = {
                prefix: 'bitcoincash',
                type: 'P2SH',
                hash,
                format: 'legacy'
            };
            break;
        case bitcoinjs_lib_1.networks.testnet.pubKeyHash:
            decoded = {
                prefix: 'bchtest',
                type: 'P2PKH',
                hash,
                format: 'legacy'
            };
            break;
        case bitcoinjs_lib_1.networks.testnet.scriptHash:
            decoded = {
                prefix: 'bchtest',
                type: 'P2SH',
                hash,
                format: 'legacy'
            };
            break;
    }
    return decoded;
};
/**
 * Generate Ethereum or any other ERC20 private key from mnemonic seed
 * @param testnet testnet or mainnet version of address
 * @param mnemonic mnemonic to generate private key from
 * @param i derivation index of private key to generate.
 * @returns blockchain private key to the address
 */
const generateEthPrivateKey = async (testnet, mnemonic, i) => {
    const path = testnet ? constants_1.TESTNET_DERIVATION_PATH : constants_1.ETH_DERIVATION_PATH;
    const hdwallet = ethereumjs_wallet_1.hdkey.fromMasterSeed(await bip39_1.mnemonicToSeed(mnemonic));
    const derivePath = hdwallet.derivePath(path).deriveChild(i);
    return derivePath.getWallet().getPrivateKeyString();
};
/**
 * Generate BSC or any other BEP-20 or BEP721 private key from mnemonic seed
 * @param testnet testnet or mainnet version of address
 * @param mnemonic mnemonic to generate private key from
 * @param i derivation index of private key to generate.
 * @returns blockchain private key to the address
 */
const generateBscPrivateKey = async (testnet, mnemonic, i) => {
    return generateEthPrivateKey(testnet, mnemonic, i);
};
/**
 * Generate Celo or any other ERC20 private key from mnemonic seed
 * @param testnet testnet or mainnet version of address
 * @param mnemonic mnemonic to generate private key from
 * @param i derivation index of private key to generate.
 * @returns blockchain private key to the address
 */
const generateCeloPrivateKey = async (testnet, mnemonic, i) => {
    const path = testnet ? constants_1.TESTNET_DERIVATION_PATH : constants_1.CELO_DERIVATION_PATH;
    const hdwallet = ethereumjs_wallet_1.hdkey.fromMasterSeed(await bip39_1.mnemonicToSeed(mnemonic));
    const derivePath = hdwallet.derivePath(path).deriveChild(i);
    return derivePath.getWallet().getPrivateKeyString();
};
/**
 * Generate VeChain private key from mnemonic seed
 * @param testnet testnet or mainnet version of address
 * @param mnemonic mnemonic to generate private key from
 * @param i derivation index of private key to generate.
 * @returns blockchain private key to the address
 */
const generateVetPrivateKey = async (testnet, mnemonic, i) => {
    const path = testnet ? constants_1.TESTNET_DERIVATION_PATH : constants_1.VET_DERIVATION_PATH;
    const hdwallet = ethereumjs_wallet_1.hdkey.fromMasterSeed(await bip39_1.mnemonicToSeed(mnemonic));
    const derivePath = hdwallet.derivePath(path).deriveChild(i);
    return derivePath.getWallet().getPrivateKeyString();
};
/**
 * Generate Scrypta private key from mnemonic seed
 * @param testnet testnet or mainnet version of address
 * @param mnemonic mnemonic to generate private key from
 * @param i derivation index of private key to generate.
 * @returns blockchain private key to the address
 */
const generateLyraPrivateKey = async (testnet, mnemonic, i) => {
    const network = testnet ? constants_1.LYRA_TEST_NETWORK : constants_1.LYRA_NETWORK;
    return bip32_1.fromSeed(await bip39_1.mnemonicToSeed(mnemonic), network)
        .derivePath(constants_1.LYRA_DERIVATION_PATH)
        .derive(i)
        .toWIF();
};
/**
 * Convert Bitcoin Private Key to Address
 * @param testnet testnet or mainnet version of address
 * @param privkey private key to use
 * @returns blockchain address
 */
const convertBtcPrivateKey = (testnet, privkey) => {
    const network = testnet ? bitcoinjs_lib_1.networks.testnet : bitcoinjs_lib_1.networks.bitcoin;
    const keyPair = bitcoinjs_lib_1.ECPair.fromWIF(privkey, network);
    return bitcoinjs_lib_1.payments.p2pkh({ pubkey: keyPair.publicKey, network }).address;
};
/**
 * Convert Scrypta Private Key to Address
 * @param testnet testnet or mainnet version of address
 * @param privkey private key to use
 * @returns blockchain address
 */
const convertLyraPrivateKey = (testnet, privkey) => {
    const network = testnet ? constants_1.LYRA_TEST_NETWORK : constants_1.LYRA_NETWORK;
    const keyPair = bitcoinjs_lib_1.ECPair.fromWIF(privkey, network);
    return bitcoinjs_lib_1.payments.p2pkh({ pubkey: keyPair.publicKey, network }).address;
};
/**
 * Convert Ethereum Private Key to Address
 * @param testnet testnet or mainnet version of address
 * @param privkey private key to use
 * @returns blockchain address
 */
const convertEthPrivateKey = (testnet, privkey) => {
    const wallet = ethereumjs_wallet_1.default.fromPrivateKey(Buffer.from(privkey.replace('0x', ''), 'hex'));
    return wallet.getAddressString();
};
/**
 * Generate address
 * @param currency type of blockchain
 * @param testnet testnet or mainnet version of address
 * @param xpub extended public key to generate address from
 * @param i derivation index of address to generate. Up to 2^31 addresses can be generated.
 * @returns blockchain address
 */
exports.generateAddressFromXPub = (currency, testnet, xpub, i) => {
    switch (currency) {
        case model_1.Currency.BTC:
            return generateBtcAddress(testnet, xpub, i);
        case model_1.Currency.TRON:
        case model_1.Currency.USDT_TRON:
            return generateTronAddress(xpub, i);
        case model_1.Currency.LTC:
            return generateLtcAddress(testnet, xpub, i);
        case model_1.Currency.DOGE:
            return generateDogeAddress(testnet, xpub, i);
        case model_1.Currency.CELO:
            return generateCeloAddress(testnet, xpub, i);
        case model_1.Currency.BCH:
            return generateBchAddress(testnet, xpub, i);
        case model_1.Currency.USDT:
        case model_1.Currency.WBTC:
        case model_1.Currency.LEO:
        case model_1.Currency.LINK:
        case model_1.Currency.UNI:
        case model_1.Currency.FREE:
        case model_1.Currency.MKR:
        case model_1.Currency.USDC:
        case model_1.Currency.BAT:
        case model_1.Currency.TUSD:
        case model_1.Currency.PAX:
        case model_1.Currency.PAXG:
        case model_1.Currency.PLTC:
        case model_1.Currency.XCON:
        case model_1.Currency.ETH:
        case model_1.Currency.BSC:
        case model_1.Currency.BETH:
        case model_1.Currency.BBTC:
        case model_1.Currency.BADA:
        case model_1.Currency.WBNB:
        case model_1.Currency.BDOT:
        case model_1.Currency.BXRP:
        case model_1.Currency.BLTC:
        case model_1.Currency.BBCH:
        case model_1.Currency.MMY:
            return generateEthAddress(testnet, xpub, i);
        case model_1.Currency.VET:
            return generateVetAddress(testnet, xpub, i);
        case model_1.Currency.LYRA:
            return generateLyraAddress(testnet, xpub, i);
        case model_1.Currency.ADA:
            return cardano_crypto_1.default.generateAddress(testnet, xpub, i);
        default:
            throw new Error('Unsupported blockchain.');
    }
};
/**
 * Generate private key from mnemonic seed
 * @param currency type of blockchain
 * @param testnet testnet or mainnet version of address
 * @param mnemonic mnemonic to generate private key from
 * @param i derivation index of private key to generate.
 * @returns blockchain private key to the address
 */
exports.generatePrivateKeyFromMnemonic = (currency, testnet, mnemonic, i) => {
    switch (currency) {
        case model_1.Currency.BTC:
            return generateBtcPrivateKey(testnet, mnemonic, i);
        case model_1.Currency.LTC:
            return generateLtcPrivateKey(testnet, mnemonic, i);
        case model_1.Currency.DOGE:
            return generateDogePrivateKey(testnet, mnemonic, i);
        case model_1.Currency.BCH:
            return generateBchPrivateKey(testnet, mnemonic, i);
        case model_1.Currency.TRON:
        case model_1.Currency.USDT_TRON:
            return generateTronPrivateKey(mnemonic, i);
        case model_1.Currency.CELO:
            return generateCeloPrivateKey(testnet, mnemonic, i);
        case model_1.Currency.USDT:
        case model_1.Currency.WBTC:
        case model_1.Currency.LEO:
        case model_1.Currency.LINK:
        case model_1.Currency.UNI:
        case model_1.Currency.FREE:
        case model_1.Currency.MKR:
        case model_1.Currency.USDC:
        case model_1.Currency.BAT:
        case model_1.Currency.TUSD:
        case model_1.Currency.PAX:
        case model_1.Currency.PAXG:
        case model_1.Currency.PLTC:
        case model_1.Currency.XCON:
        case model_1.Currency.ETH:
        case model_1.Currency.BSC:
        case model_1.Currency.BETH:
        case model_1.Currency.BBTC:
        case model_1.Currency.BADA:
        case model_1.Currency.WBNB:
        case model_1.Currency.BDOT:
        case model_1.Currency.BXRP:
        case model_1.Currency.BLTC:
        case model_1.Currency.BBCH:
        case model_1.Currency.MMY:
            return generateEthPrivateKey(testnet, mnemonic, i);
        case model_1.Currency.VET:
            return generateVetPrivateKey(testnet, mnemonic, i);
        case model_1.Currency.LYRA:
            return generateLyraPrivateKey(testnet, mnemonic, i);
        case model_1.Currency.ADA:
            return cardano_crypto_1.default.generatePrivateKey(mnemonic, i);
        default:
            throw new Error('Unsupported blockchain.');
    }
};
/**
 * Generate address from private key
 * @param currency type of blockchain
 * @param testnet testnet or mainnet version of address
 * @param privateKey private key to use
 * @returns blockchain private key to the address
 */
exports.generateAddressFromPrivatekey = (currency, testnet, privateKey) => {
    switch (currency) {
        case model_1.Currency.BTC:
            return convertBtcPrivateKey(testnet, privateKey);
        case model_1.Currency.LYRA:
            return convertLyraPrivateKey(testnet, privateKey);
        case model_1.Currency.ETH:
        case model_1.Currency.USDT:
        case model_1.Currency.WBTC:
        case model_1.Currency.LEO:
        case model_1.Currency.LINK:
        case model_1.Currency.UNI:
        case model_1.Currency.FREE:
        case model_1.Currency.MKR:
        case model_1.Currency.USDC:
        case model_1.Currency.BAT:
        case model_1.Currency.TUSD:
        case model_1.Currency.PAX:
        case model_1.Currency.PAXG:
        case model_1.Currency.PLTC:
        case model_1.Currency.XCON:
        case model_1.Currency.BSC:
        case model_1.Currency.MMY:
            return convertEthPrivateKey(testnet, privateKey);
        default:
            throw new Error('Unsupported blockchain.');
    }
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWRkcmVzcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy93YWxsZXQvYWRkcmVzcy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsaUNBQTBEO0FBQzFELGlDQUFxQztBQUNyQyxpREFBeUQ7QUFDekQsdUVBQStEO0FBQy9ELGFBQWE7QUFDYiw0Q0FpQnNCO0FBQ3RCLG9DQUFrQztBQUNsQywrQ0FBOEM7QUFDOUMsc0VBQXVDO0FBQ3ZDLGlDQUFpQztBQUNqQyxNQUFNLEtBQUssR0FBRyxPQUFPLENBQUMsNkJBQTZCLENBQUMsQ0FBQztBQUNyRCxNQUFNLFFBQVEsR0FBRyxPQUFPLENBQUMsWUFBWSxDQUFDLENBQUM7QUFDdkMsTUFBTSxRQUFRLEdBQUcsT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDO0FBQ3JDLDJDQUEyQztBQUMzQyxNQUFNLE9BQU8sR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUM7QUFnQm5DOzs7Ozs7R0FNRztBQUNILE1BQU0sa0JBQWtCLEdBQUcsQ0FBQyxPQUFnQixFQUFFLElBQVksRUFBRSxDQUFTLEVBQUUsRUFBRTtJQUNyRSxNQUFNLE9BQU8sR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDLHdCQUFRLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyx3QkFBUSxDQUFDLE9BQU8sQ0FBQztJQUM5RCxNQUFNLENBQUMsR0FBRyxrQkFBVSxDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDMUQsT0FBTyx3QkFBUSxDQUFDLEtBQUssQ0FBQyxFQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsU0FBUyxFQUFFLE9BQU8sRUFBQyxDQUFDLENBQUMsT0FBaUIsQ0FBQztBQUM1RSxDQUFDLENBQUM7QUFFRjs7Ozs7O0dBTUc7QUFDSCxNQUFNLG1CQUFtQixHQUFHLENBQUMsT0FBZ0Is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